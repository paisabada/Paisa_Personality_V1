<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Paisa — OG Name Placer (No box + contain)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:Inter,Arial,Helvetica,sans-serif;margin:16px;background:#f3f6fb;color:#0f172a;display:flex;gap:16px;align-items:flex-start}
  .panel{width:360px;background:#fff;padding:14px;border-radius:10px;box-shadow:0 8px 20px rgba(2,6,23,0.06)}
  h3{margin:0 0 6px 0}
  label{display:block;margin-top:10px;font-weight:600;color:#102a43}
  select,input,button{width:100%;padding:10px;border-radius:8px;border:1px solid #e6eef6;margin-top:6px;font-size:14px}
  .small{font-size:13px;color:#566; margin-top:8px}
  canvas{border-radius:8px;box-shadow:0 12px 30px rgba(2,6,23,0.08);background:#000;display:block}
  .btn{padding:9px;border-radius:8px;border:0;cursor:pointer}
  .btn-primary{background:#0b69ff;color:#fff}
  .btn-ghost{background:#fff;border:1px solid #e6eef6}
  .slider{width:100%}
  .mini{font-size:12px;color:#667}
</style>
</head>
<body>

<div class="panel">
  <h3>Paisa OG Name Placer — No box</h3>
  <div class="small">Removed white box. Images are now drawn to *contain* so full image visible. Use sliders to nudge name so it doesn't overlap faces.</div>

  <label>Select OG image</label>
  <select id="ogSelect"></select>

  <label>Name (text to place)</label>
  <input id="nameInput" placeholder="Type name (e.g. Ravi)" maxlength="28"/>

  <label>Vertical offset (nudge name up/down)</label>
  <input id="offsetSlider" type="range" min="-300" max="300" value="0" class="slider"/>
  <div class="mini">Negative = move up, Positive = move down.</div>

  <label>Font scale (%)</label>
  <input id="scaleSlider" type="range" min="50" max="200" value="100" class="slider"/>

  <div style="display:flex;gap:8px;margin-top:8px;">
    <button id="applyBtn" class="btn btn-primary">Preview</button>
    <button id="downloadBtn" class="btn btn-ghost">Download PNG</button>
  </div>

  <div style="display:flex;gap:8px;margin-top:8px;">
    <button id="resetBtn" class="btn btn-ghost">Reset</button>
    <button id="saveBtn" class="btn btn-ghost">Save (local)</button>
  </div>

  <div class="small" style="margin-top:8px">
    Tip: choose image → type name → nudge with vertical offset → save. If name still overlaps, reduce Font scale or move it.
  </div>
</div>

<div>
  <canvas id="ogCanvas" width="1200" height="630"></canvas>
  <div class="small">Preview (1200×630). After download, test Facebook/Twitter card debugger.</div>
</div>

<script>
/* ---------- CONFIG: replace src values with your actual raw GitHub image URLs ---------- */
const images = [
  { id:'budget', label:'Budget Boss', src:'https://raw.githubusercontent.com/paisabada/Paisa_Personality_V1/refs/heads/main/budget_boss_og.png', def:{x:600,y:470,font:120}},
  { id:'risky', label:'Risky Rockstar', src:'https://raw.githubusercontent.com/paisabada/Paisa_Personality_V1/refs/heads/main/risky_rockstar_og.png', def:{x:600,y:380,font:120}},
  { id:'panda', label:'Investor Panda', src:'https://raw.githubusercontent.com/paisabada/Paisa_Personality_V1/refs/heads/main/investor_panda_og.png', def:{x:600,y:500,font:120}}
];
/* ------------------------------------------------------------------------------------- */

const canvas = document.getElementById('ogCanvas');
const ctx = canvas.getContext('2d');
const ogSelect = document.getElementById('ogSelect');
const nameInput = document.getElementById('nameInput');
const offsetSlider = document.getElementById('offsetSlider');
const scaleSlider = document.getElementById('scaleSlider');
const applyBtn = document.getElementById('applyBtn');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');
const saveBtn = document.getElementById('saveBtn');

const storageKey = 'paisa_og_settings_v2';
let saved = {};
try { saved = JSON.parse(localStorage.getItem(storageKey) || '{}'); } catch(e){ saved = {}; }

function saveLocal(){ localStorage.setItem(storageKey, JSON.stringify(saved)); }

images.forEach(it=>{
  const o = document.createElement('option'); o.value=it.id; o.textContent=it.label; ogSelect.appendChild(o);
});

let current = { img:null, cfg:null };

function loadImage(cfg){
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = () => {
    current = { img, cfg };
    // set sliders from saved
    const s = saved[cfg.id] || {};
    offsetSlider.value = s.offset || 0;
    scaleSlider.value = s.scalePct || 100;
    render();
  };
  img.onerror = () => {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#eee'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#333'; ctx.font='16px Arial'; ctx.textAlign='center';
    ctx.fillText('Failed to load: '+cfg.src, canvas.width/2, canvas.height/2);
  };
  img.src = cfg.src;
}

/* draw image in CONTAIN mode (fit fully inside canvas) */
function drawContain(img){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
  const iw = img.width * scale, ih = img.height * scale;
  const ix = (canvas.width - iw)/2, iy = (canvas.height - ih)/2;
  ctx.drawImage(img, ix, iy, iw, ih);
  return {ix,iy,iw,ih};
}

/* draw name WITHOUT box; use stroke + shadow to ensure readability */
function drawNameWithoutBox(cfg){
  const name = nameInput.value.trim();
  if(!name) return;
  const s = saved[cfg.id] || {};
  const offset = Number(offsetSlider.value || 0);
  const scalePct = Number(scaleSlider.value || 100)/100;
  let baseFont = (cfg.def && cfg.def.font) ? cfg.def.font : 120;
  baseFont = Math.round(baseFont * scalePct);

  // start with baseFont, but shrink if text too wide
  ctx.font = `700 ${baseFont}px Poppins, Arial`;
  let measured = ctx.measureText(name).width;
  const maxW = canvas.width * 0.85;
  while(measured > maxW && baseFont > 18){
    baseFont -= 4;
    ctx.font = `700 ${baseFont}px Poppins, Arial`;
    measured = ctx.measureText(name).width;
  }

  // final coordinates
  const x = (s.x || cfg.def.x || canvas.width/2);
  const y = (s.y || cfg.def.y || canvas.height*0.6) + offset;

  // pick text color by sampling area behind (to decide stroke/light)
  // sample small area
  let sampleColor = {r:30,g:30,b:30};
  try {
    const sx = Math.max(0, Math.round(x - measured/2));
    const sy = Math.max(0, Math.round(y - baseFont));
    const sw = Math.min(canvas.width - sx, Math.round(measured));
    const sh = Math.min(canvas.height - sy, Math.round(baseFont*1.2));
    const data = ctx.getImageData(sx,sy,Math.max(1,sw),Math.max(1,sh)).data;
    let r=0,g=0,b=0,c=0;
    for(let i=0;i<data.length;i+=4){ r+=data[i]; g+=data[i+1]; b+=data[i+2]; c++; }
    sampleColor = {r: Math.round(r/c), g: Math.round(g/c), b: Math.round(b/c)};
  } catch(e){ /* ignore cross-origin errors - fallback to dark */ }

  const lum = (0.2126*sampleColor.r + 0.7152*sampleColor.g + 0.0722*sampleColor.b)/255;
  const useWhite = lum < 0.55; // if bg is dark -> white text

  // text shadow + stroke for contrast (no rectangle)
  ctx.font = `700 ${baseFont}px Poppins, Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  if(useWhite){
    ctx.fillStyle = '#ffffff';
    ctx.lineWidth = Math.max(3, Math.round(baseFont*0.06));
    ctx.strokeStyle = 'rgba(0,0,0,0.45)';
    ctx.shadowColor = 'rgba(0,0,0,0.35)';
    ctx.shadowBlur = 8;
  } else {
    ctx.fillStyle = '#073018';
    ctx.lineWidth = Math.max(2, Math.round(baseFont*0.05));
    ctx.strokeStyle = 'rgba(255,255,255,0.85)';
    ctx.shadowColor = 'rgba(0,0,0,0.05)';
    ctx.shadowBlur = 0;
  }

  // draw stroke then fill - stroke helps legibility without box
  ctx.lineJoin = 'round';
  ctx.strokeText(name, x, y);
  ctx.fillText(name, x, y);

  // cleanup shadows
  ctx.shadowBlur = 0;
}

/* MAIN render */
function render(){
  if(!current.img || !current.cfg) return;
  drawContain(current.img);
  drawNameWithoutBox(current.cfg);
}

/* UI events */
ogSelect.addEventListener('change', ()=> {
  const id = ogSelect.value;
  const cfg = images.find(i=>i.id===id);
  loadImage(cfg);
});
applyBtn.addEventListener('click', render);
nameInput.addEventListener('input', render);
offsetSlider.addEventListener('input', render);
scaleSlider.addEventListener('input', render);

downloadBtn.addEventListener('click', ()=>{
  render();
  const a = document.createElement('a');
  a.href = canvas.toDataURL('image/png');
  a.download = 'paisa_result.png';
  a.click();
});

saveBtn.addEventListener('click', ()=>{
  if(!current.cfg) return;
  const id = current.cfg.id;
  saved[id] = saved[id] || {};
  saved[id].offset = Number(offsetSlider.value||0);
  saved[id].scalePct = Number(scaleSlider.value||100);
  // keep defaults x,y,font if present in def
  saved[id].x = saved[id].x || current.cfg.def.x;
  saved[id].y = saved[id].y || current.cfg.def.y;
  saved[id].font = saved[id].font || current.cfg.def.font;
  saveLocal();
  alert('Settings saved locally for ' + current.cfg.label);
});
resetBtn.addEventListener('click', ()=>{
  if(!current.cfg) return;
  const id = current.cfg.id;
  if(saved[id]) delete saved[id];
  saveLocal();
  offsetSlider.value = 0;
  scaleSlider.value = 100;
  render();
  alert('Reset done for ' + current.cfg.label);
});

/* init */
(function init(){
  // set default select and load
  ogSelect.value = images[0].id;
  loadImage(images[0]);
})();
</script>
</body>
</html>
