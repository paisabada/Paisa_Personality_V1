<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Paisa OG Name Placer — per-image safe placement</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:Inter,system-ui,Arial,sans-serif;margin:18px;background:#f3f4f6;color:#111;display:flex;gap:18px;align-items:flex-start}
  .panel{width:360px;background:#fff;padding:14px;border-radius:10px;box-shadow:0 8px 24px rgba(8,12,20,0.06)}
  label{display:block;margin-top:10px;font-weight:600;color:#223}
  select,input{width:100%;padding:10px;border-radius:8px;border:1px solid #e5e7eb;margin-top:6px;font-size:15px}
  button{padding:10px 12px;border-radius:8px;border:0;cursor:pointer;margin-top:10px}
  .btn-primary{background:#2563eb;color:#fff}
  .btn-ghost{background:#fff;border:1px solid #ddd}
  canvas{border-radius:10px;box-shadow:0 12px 30px rgba(2,6,23,0.08);background:#000}
  .hint{font-size:13px;color:#556; margin-top:8px}
  .small{font-size:13px;color:#666;margin-top:6px}
</style>
</head>
<body>

<div class="panel">
  <h3 style="margin:0 0 6px 0">Paisa — Safe Name Placer</h3>
  <div class="small">Positions pre-tuned for your 3 OG images; auto color + background box for readability.</div>

  <label>Choose OG image</label>
  <select id="ogSelect"></select>

  <label>Name (will be placed on image)</label>
  <input id="nameInput" type="text" placeholder="Type name (e.g. Ravi)" maxlength="30" />

  <label>Mobile (optional)</label>
  <input id="mobInput" type="tel" placeholder="Not drawn — saved for record" />

  <label>Email (optional)</label>
  <input id="emailInput" type="email" placeholder="Not drawn — saved for record" />

  <div style="display:flex;gap:8px;">
    <button id="applyBtn" class="btn-primary">Apply</button>
    <button id="downloadBtn" class="btn-ghost">Download PNG</button>
  </div>

  <div class="hint">
    If position needs tiny tweak later I can move that image's Y value — but this is tuned to avoid faces/artwork.
  </div>
</div>

<div>
  <canvas id="ogCanvas" width="1200" height="630"></canvas>
  <div class="small">Preview 1200×630 — click Download to save PNG for testing.</div>
</div>

<script>
/* Configuration:
   - images: array of objects {id, label, src, nameY, preferColor}
     nameY = vertical canvas coordinate where the name baseline will sit (px)
     preferColor = optional override, 'auto' = sample color
*/
const images = [
  { id:'budget', label:'Budget Boss', src:'budget_boss_og.png', nameY: 420, preferColor: 'auto' },
  { id:'risky', label:'Risky Rockstar', src:'risky_rockstar_og.png', nameY: 360, preferColor: 'auto' },
  { id:'panda', label:'Investor Panda', src:'investor_panda_og.png', nameY: 430, preferColor: 'auto' }
];

const canvas = document.getElementById('ogCanvas');
const ctx = canvas.getContext('2d');
const ogSelect = document.getElementById('ogSelect');
const nameInput = document.getElementById('nameInput');
const applyBtn = document.getElementById('applyBtn');
const downloadBtn = document.getElementById('downloadBtn');

const canvasW = canvas.width, canvasH = canvas.height;
const maxNameWidth = Math.round(canvasW * 0.78);
const fontBase = '700';
const fontFamily = 'Poppins, Arial, sans-serif';

// fill select
images.forEach(img => {
  const opt = document.createElement('option');
  opt.value = img.id;
  opt.textContent = img.label + ' (' + img.src + ')';
  ogSelect.appendChild(opt);
});

// map id -> object for quick lookup
const imgMap = {};
images.forEach(i => imgMap[i.id] = i);

// load image by id
let currentImage = null;
function loadImageById(id) {
  const cfg = imgMap[id];
  if(!cfg) return;
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = function(){
    currentImage = {img:img, cfg:cfg};
    render();
  };
  img.onerror = function(){
    ctx.clearRect(0,0,canvasW,canvasH);
    ctx.fillStyle = '#eee';
    ctx.fillRect(0,0,canvasW,canvasH);
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Image failed to load: ' + cfg.src, canvasW/2, canvasH/2);
  };
  img.src = cfg.src;
}

// draw base image cover (cover behavior)
function drawBase(img) {
  ctx.clearRect(0,0,canvasW,canvasH);
  const ratio = Math.max(canvasW/img.width, canvasH/img.height);
  const iw = img.width*ratio, ih = img.height*ratio;
  const ix = (canvasW - iw)/2, iy = (canvasH - ih)/2;
  ctx.drawImage(img, ix, iy, iw, ih);
  // return rectangle area where image actually sits (useful if we want to sample)
  return {ix,iy,iw,ih};
}

// sample average color in a small box around name area to decide light/dark text
function sampleAreaColor(x, y, w, h) {
  try {
    const sx = Math.max(0, Math.round(x - w/2));
    const sy = Math.max(0, Math.round(y - h/2));
    const sw = Math.min(canvasW - sx, Math.round(w));
    const sh = Math.min(canvasH - sy, Math.round(h));
    const data = ctx.getImageData(sx, sy, sw, sh).data;
    let r=0,g=0,b=0,count=0;
    for(let i=0;i<data.length;i+=4){
      r += data[i]; g += data[i+1]; b += data[i+2]; count++;
    }
    r = Math.round(r/count); g = Math.round(g/count); b = Math.round(b/count);
    return {r,g,b};
  } catch(e){
    // security/CORS or other error -> fallback to dark bg
    return {r:40,g:40,b:40};
  }
}

// luminance -> 0..1
function luminance(rgb){ return (0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b)/255; }

function drawName(name, cfg) {
  if(!name) return;
  // font sizing loop
  let fontSize = 110;
  ctx.textBaseline = 'middle';
  ctx.textAlign = 'center';
  ctx.font = `${fontBase} ${fontSize}px ${fontFamily}`;
  let measured = ctx.measureText(name).width;
  while(measured > maxNameWidth && fontSize > 18){
    fontSize -= 2;
    ctx.font = `${fontBase} ${fontSize}px ${fontFamily}`;
    measured = ctx.measureText(name).width;
  }

  const x = canvasW/2;
  const y = cfg.nameY;

  // sample average color in the area to choose light/dark text
  const sample = sampleAreaColor(x, y, Math.min(measured, maxNameWidth), Math.max(40, fontSize*1.2));
  const lum = luminance(sample);
  // if background is dark -> use white text; if light -> use dark text
  const useWhite = (lum < 0.55);

  // draw translucent rounded rectangle behind text for guaranteed legibility
  const paddingX = 28, paddingY = Math.round(fontSize*0.45);
  const rectW = measured + paddingX*2;
  const rectH = fontSize + paddingY*2;
  const rectX = x - rectW/2;
  const rectY = y - rectH/2;
  // rectangle color - choose opposite of text with low opacity
  ctx.save();
  ctx.beginPath();
  const radius = 12;
  roundRectPath(ctx, rectX, rectY, rectW, rectH, radius);
  ctx.closePath();
  if(useWhite){
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
  } else {
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
  }
  ctx.fill();
  ctx.restore();

  // draw text with subtle shadow if needed
  ctx.save();
  if(useWhite){
    ctx.fillStyle = '#ffffff';
    ctx.shadowColor = 'rgba(0,0,0,0.55)';
    ctx.shadowBlur = 10;
  } else {
    ctx.fillStyle = '#0b2a1a'; // dark greenish (looks nice on light backgrounds)
    ctx.shadowColor = 'rgba(255,255,255,0.2)';
    ctx.shadowBlur = 0;
  }
  ctx.font = `${fontBase} ${fontSize}px ${fontFamily}`;
  ctx.fillText(name, x, y);
  ctx.restore();
}

// helper to draw rounded rect path
function roundRectPath(ctx, x, y, w, h, r){
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
}

// render entire preview
function render(){
  if(!currentImage) return;
  const cfg = currentImage.cfg;
  drawBase(currentImage.img);
  drawName(nameInput.value.trim(), cfg);
}

// UI wiring
ogSelect.addEventListener('change', function(){ loadImageById(this.value); });
applyBtn.addEventListener('click', render);
nameInput.addEventListener('input', render);
downloadBtn.addEventListener('click', function(){
  render();
  const link = document.createElement('a');
  link.download = 'paisa_result.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
});

// populate select with our images array values (use src as text)
(function initSelect(){
  const sel = ogSelect;
  sel.innerHTML = '';
  images.forEach(it=>{
    const o = document.createElement('option'); o.value = it.id; o.textContent = it.label + ' — ' + it.src;
    sel.appendChild(o);
  });
  // load first by default
  loadImageById(images[0].id);
})();

function loadImageById(id){
  const cfg = imgMap[id] || images.find(i=>i.id===id);
  if(!cfg) return;
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = function(){ currentImage = {img, cfg}; render(); };
  img.onerror = function(){
    ctx.clearRect(0,0,canvasW,canvasH);
    ctx.fillStyle = '#eee'; ctx.fillRect(0,0,canvasW,canvasH);
    ctx.fillStyle = '#333'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font = '16px Arial';
    ctx.fillText('Failed to load: ' + cfg.src, canvasW/2, canvasH/2);
  };
  img.src = cfg.src;
}
</script>
</body>
</html>
